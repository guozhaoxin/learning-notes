## 保守式 GC

保守式 GC 是指不能识别指针和非指针的 GC；比如栈中有一个值，它在程序中只是一个普通数据，但是这个数据值正好代表堆中一个有效对象的地址，则该值会被认为是个指针，进而将相应的对象识别为活动对象，导致识别错误；但是它只是可能将非活动对象识别为活动对象，而不会反过来。

### 优点

保守式的优点在于编写程序比较容易，算法与语言无关。

### 缺点

缺点比较多。

- 识别指针和非指针需要成本；
- 错误识别会压迫堆，会使得 gc 时无效时间变长，特别是一个拥有大量引用的非活动对象被当成是活动对象时；
- 能使用的 GC 算法有限，为了防止将一个数值错误识别成指针，任何在 gc 时会移动对象的 gc 算法都是无法使用的，即只能使用诸如 **标记-清除** 而不是 **标记-复制** 这一类的算法。



## 准确式 GC

准确式  GC，是指可以准确识别指针和非指针的算法。不过这往往需要语言层面上有方法辅助。

### 打标签法

因为 cpu 的特性，如果一个对象的某个域是其它对象的引用，那么它的值是有讲究的，32 位 cpu 下，后两位是 0，64 位 cpu 下后 3 位是 0；因此可以使用这些位做一些额外的事情，比如将最低 1 位置为 1 表示其非指针，而 0 表示指针；

但是这也有问题：

- 对非指针字段赋值时，往往需要先左移一定位数，然后与地方、 1 进行位操作；
- 由于要左移，有可能发生溢出，因此在必要的时候，需要对变量类型进行升级；
- 获取到一个非指针字段的值后，不能直接使用，要先执行右移操作；



## 黑名单法

所谓黑名单法，是一种改进型的保守式 gc。它有一个叫做黑名单的数据集，专门用来记录一些危险的地址，这些地址上并没有分配空间，但是被根上有一些值的数值被解释为指针时，会指向这些地方；因此在分配对象时，要尽量避开这些地方；当然如果要分配的对象比较小，或者没有引用的对象，分配这喜色地址也无所谓，顶多就是被遍历一次。