### rabbit 主从

rabbit 本身是支持集群的，可以有多个 broker，可以做到将 vhost exchange 以及绑定关系的高可用（不过rabbit集群中的节点有两类型，一类是disk节点，是默认的类型，表示需要持久化的信息会存储到硬盘；一类是 memory 类型，表示只会将这些信息存储到内存），但是队列的高可用却是问题，因为队列中消息的存储只能在单个节点上，因此一旦节点挂掉，就会导致相关队列都不可用。

为此 rabbit 引入镜像队列，它的含义是一个队列会选取一个节点作为 master 节点对外服务，它会有一些镜像队列分布在其它节点上，可以指定数量，这些节点会是这个队列的 slave 节点，这一点是有点像kafka的。生产者发布消息时，并不是master转发给其它节点，而是生产者直接发送给master和slave节点（<font color=red>这里如何保证消息都能准确投递到呢？</font>）。而消费时，则只能由master节点进行处理，即使客户端连接到了一个slave节点，消息的请求也是经slave转发给master，再由slave转给消费者。

master节点会将自己和所有slave节点作为一个环形链表，slave也会记录这个链表，每个节点都会关注自己的两个相邻节点；当master发布消息时，会顺着链表将信息传递下去，如果master最终收到这条消息，则表示所有节点已经收到了这条信息。基于这种方式，它实现了消息的可靠传递。如果有节点挂了，则相邻节点也会将它挂掉的消息进行广播。

当master挂掉时，会从最古老的slave中选择作为新的master。这时就会有一些问题，比如slave节点与master不同步，其实会有一些消息丢失；第二是新的master不知道那些还未确认的消息是什么状态，它主政后，会一股脑将所有这些消息置为待确认，这就容易出现重复消费问题。



### 惰性队列  

主要就是会一股脑将所有消息都直接写入文件 ，不在内存放置，不管消息是否要持久化；好处就是内存压力低，坏处是IO压力大。重启后，队列中的消息依然在磁盘，但是已经不可被消费。



### 阻塞

rabbit 中，任意一个broker出现性能问题（内存达到阈值或者磁盘打到阈值）时，都会导致集群被阻塞，此时生产者和消费者都会被阻塞，因为任意一个 channel 都可以同时承载生产者和消费者，而任意一个connection又能同时承载很多channel，使得rabbit没办法只对生产者阻塞而不阻塞消费者。